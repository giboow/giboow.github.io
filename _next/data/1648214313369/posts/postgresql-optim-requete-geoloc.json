{"pageProps":{"postData":{"id":"postgresql-optim-requete-geoloc","contentHtml":"<p>R√©cemment j‚Äôai voulu cr√©er une petite application mobile qui permet de rechercher les bo√Ætes aux lettres qui sont autour de la g√©olocalisation utilisateur. D‚Äôautres apps existent, mais leurs performances n‚Äô√©taient pas vraiment au rendez-vous, alors j‚Äôai voulu tenter de trouver des solutions!</p>\n<p>Pour commencer, j‚Äôai r√©ussi √† r√©cup√©rer un jeu de donn√©e sur le site <a href=\"http://data.gouv.fr/\">data.gouv.fr</a> : <a href=\"https://www.data.gouv.fr/fr/datasets/liste-des-boites-aux-lettres-de-rue-france-metropolitaine-et-dom-avec-heure-limite-de-depot-1/\">https://www.data.gouv.fr/fr/datasets/liste-des-boites-aux-lettres-de-rue-france-metropolitaine-et-dom-avec-heure-limite-de-depot-1/</a> . Ce jeu de donn√©es comporte 140 000 entr√©es, bien s√ªr l‚Äôutilisateur qui va vouloir afficher les bo√Ætes aux lettres proches de lui, n‚Äôaura pas besoin d‚Äôafficher toutes les bo√Ætes disponibles dans la base de donn√©es, mais seulement celles proches de lui, par exemple 10km.</p>\n<p>Pour mon projet j‚Äôutilise une API SpringBoot, mais ce n‚Äôest pas ce qui va vous int√©resser aujourd‚Äôhui. Le vrai probl√®me c‚Äôest comment r√©cup√©rer l‚Äôensemble des donn√©es, stock√©es dans une base de donn√©es PostgreSQL, qui sont g√©olocalis√©es proche d‚Äôun point dans un temps convenable!</p>\n<h2>L‚Äôobjectif</h2>\n<p>Mon objectif est donc de trouver un ensemble de points qui se trouvent dans un rayon de 10km, en un temps record!</p>\n<p><img src=\"/static/images/post/postgres-geoloc-optim.png\" alt=\"Objectif de la requete\"></p>\n<h2>PostGIS √† la rescousse</h2>\n<p>PostGIS est une extension de PostgreSQL, elle permet d‚Äôoffrir de nouvelle fonction et des types de donn√©es qui facilitent les recherches g√©olocalis√©es.</p>\n<p>Pour installer PostGIS sur son serveur :</p>\n<pre><code>~$ sudo apt install postgis\n</code></pre>\n<p>Il faut ensuite l‚Äôactiver dans PosgresSQL, en se connectant √† la base de donn√©es et en ajoutant l‚Äôextension <strong>postgis</strong>. Elle sera donc active uniquement dans la base de donn√©es s√©lectionn√©e.</p>\n<pre><code>psql (13.6 (Ubuntu 13.6-0ubuntu0.21.10.1))\nType \"help\" for help.\n\npostgres=# \\c test;\npostgres=# CREATE EXTENSION postgis;\n</code></pre>\n<p>Nous pouvons maintenant cr√©er une table qui contient un id, une latitude, une longitude ainsi qu‚Äôun point GPS.  La valeur du SRID <strong>4326</strong>  permet de d√©clarer un point utilisant le syst√®me de r√©f√©rence spatiale g√©ographique.</p>\n<pre><code>CREATE TABLE public.test (\n    id bigserial NOT NULL,\n    lat real NOT NULL,\n    long real NOT NULL,\n    location geography(Point, 4326) NOT NULL\n);\n</code></pre>\n<p>On peut alors facilement ajouter un point en utilisant la requ√™te suivante :</p>\n<pre><code>INSERT INTO test (lat, long, location)\nVALUES (49.548462,1.0779799,ST_SetSRID(ST_MakePoint(49.548462,1.0779799), 4326));\n</code></pre>\n<h2>Optimisation</h2>\n<p>Pour valider mon optimisation, j‚Äôai ajout√© √† ma table 140 000 lignes de donn√©es g√©olocalis√©es.</p>\n<p>B√™tement j‚Äôai voulu rechercher tous les points qui se trouvaient dans un rayon de moins de 10km avec la fonction <strong>st_distancesphere</strong>.</p>\n<p>Voici la requ√™te que j‚Äôex√©cute pour r√©cup√©rer tous les points GPS dans un rayon de 10km :</p>\n<pre><code>EXPLAIN(ANALYSE , BUFFERS )\nSELECT st_distancesphere(t.location::geometry,ST_SetSRID(ST_MakePoint(49.548462,1.0779799), 4326))\nFROM test t\nWHERE\nst_distancesphere(t.location::geometry,ST_SetSRID(ST_MakePoint(49.548462,1.0779799), 4326)) &#x3C; 10000;\n</code></pre>\n<p>L‚Äôanalyser de requ√™te de PostgeSQL montre bien qu‚Äôaucun index n‚Äôest utilis√© et que la requ√™te prend 463ms pour renvoyer 21 points qui correspondes aux conditions.</p>\n<pre><code>Gather  (cost=1000.00..2776968.00 rows=47062 width=8) (actual time=160.851..461.391 rows=115 loops=1)\n  Workers Planned: 1\n  Workers Launched: 1\n  Buffers: shared hit=1759\n  ->  Parallel Seq Scan on test t  (cost=0.00..2771261.80 rows=27684 width=8) (actual time=218.887..415.046 rows=58 loops=2)\n\"        Filter: (st_distance(geography((location)::geometry), '0101000020E6100000A48CB80034C64840F5EC03DA673FF13F'::geography, false) &#x3C; '10000'::double precision)\"\n        Rows Removed by Filter: 70535\n        Buffers: shared hit=1759\nPlanning Time: 0.376 ms\nJIT:\n  Functions: 8\n\"  Options: Inlining true, Optimization true, Expressions true, Deforming true\"\n\"  Timing: Generation 2.485 ms, Inlining 178.841 ms, Optimization 117.797 ms, Emission 56.983 ms, Total 356.106 ms\"\nExecution Time: 463.431 ms\n</code></pre>\n<p>Nous allons donc cr√©er un index qui va permettre d‚Äôacc√©l√©rer la requ√™te (voir  la doc <a href=\"http://postgis.net/workshops/postgis-intro/indexing.html\">http://postgis.net/workshops/postgis-intro/indexing.html</a>):</p>\n<pre><code>CREATE INDEX test_position_geography_index ON test USING GIST(geography(location));\n</code></pre>\n<p>Mais nous allons avoir une mauvaise surprise, car l‚Äôindex ne fonctionne toujours pas. Apr√®s une recherche rapide, je me suis aper√ßu qu‚Äôil n‚Äôy a que certaines fonctions de PostGIS qui peuvent utiliser l‚Äôindexation (voir la doc ici : <a href=\"http://postgis.net/workshops/postgis-intro/indexing.html#spatially-indexed-functions\">http://postgis.net/workshops/postgis-intro/indexing.html#spatially-indexed-functions</a>).</p>\n<p>Je d√©cide donc d‚Äôutiliser la fonction ST_DWithin qui renvoie un vrai si deux points se trouvent bien √† la distance pass√©e dans le 3e param√®tre.</p>\n<p>Voici donc la requ√™te suivie de l‚Äôanalyse :</p>\n<pre><code>EXPLAIN(ANALYSE , BUFFERS )\nSELECT st_distancesphere(t.location::geometry,ST_SetSRID(ST_MakePoint(49.548462,1.0779799), 4326))\nFROM test t\nWHERE\n   ST_DWithin(t.location, ST_SetSRID(ST_MakePoint(49.548462,1.0779799), 4326)::geography, 10000);\n</code></pre>\n<pre><code>Bitmap Heap Scan on test t  (cost=4.95..2390.34 rows=14 width=8) (actual time=1.212..2.205 rows=115 loops=1)\n\"  Filter: st_dwithin(location, '0101000020E6100000A48CB80034C64840F5EC03DA673FF13F'::geography, '10000'::double precision, true)\"\n  Rows Removed by Filter: 200\n  Heap Blocks: exact=150\n  Buffers: shared hit=188\n  ->  Bitmap Index Scan on test_position_geography_index  (cost=0.00..4.95 rows=72 width=0) (actual time=0.288..0.288 rows=315 loops=1)\n\"        Index Cond: (location &#x26;&#x26; _st_expand('0101000020E6100000A48CB80034C64840F5EC03DA673FF13F'::geography, '10000'::double precision))\"\n        Buffers: shared hit=26\nPlanning Time: 0.446 ms\nExecution Time: 2.288 ms\n</code></pre>\n<p>On voit bien que l‚Äôindex <strong>test_position_geography_index</strong> est utilis√© et qu‚Äôil permet de r√©cup√©rer les 21 points en <strong>2.288ms</strong> ü§Ø. ****Le gain est √©norme, il permet de r√©duire consid√©rablement le temps d‚Äôex√©cution et le temps d‚Äôutilisation processeur.</p>\n<h2>Bilan</h2>\n<p>Dans mon API de g√©olocalisation de bo√Ætes aux lettres, cela m‚Äôa permis de diviser par 10 le temps de requ√™te et de soulager le serveur lorsque je simulais une charge serveur avec l‚Äôoutil de tests de performance d‚ÄôApache <strong>ab</strong> (<a href=\"https://httpd.apache.org/docs/2.4/fr/programs/ab.html\">https://httpd.apache.org/docs/2.4/fr/programs/ab.html</a>).</p>\n","author":"giboow","title":"PostgreSQL - Comment booster ses recherches de point g√©olocalis√©","date":"2022-03-24","keywords":["PostgreSQL","PostGIS","Latitude","Longitude","Optimisation","SQL"],"image":"/static/images/post/postgres-geoloc-optim.png"}},"__N_SSG":true}