<!DOCTYPE html><html class="has-navbar-fixed-top"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="stylesheet" type="text/css" href="/static/css/nprogress.css"/><title>PostgreSQL - Comment booster ses recherches de point géolocalisé</title><meta name="keywords" content="PostgreSQL,PostGIS,Latitude,Longitude,Optimisation,SQL"/><meta name="title" content="PostgreSQL - Comment booster ses recherches de point géolocalisé"/><meta name="next-head-count" content="6"/><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css"/><link rel="shortcut icon" href="/static/images/icons/favicon.ico"/><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /><link rel="preload" href="/_next/static/css/f5574a0b1daeb724.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f5574a0b1daeb724.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-cb7634a8b6194820.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-01df828e572375b9.js" defer=""></script><script src="/_next/static/chunks/pages/_app-87c410e52863226c.js" defer=""></script><script src="/_next/static/chunks/a9a7754c-05c682ba86311bbe.js" defer=""></script><script src="/_next/static/chunks/75fc9c18-c2ffd8d428a8879e.js" defer=""></script><script src="/_next/static/chunks/543-f2ed9e3420d49453.js" defer=""></script><script src="/_next/static/chunks/890-caa6605737b38c22.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-d8fceaa95569ffd1.js" defer=""></script><script src="/_next/static/1648214313369/_buildManifest.js" defer=""></script><script src="/_next/static/1648214313369/_ssgManifest.js" defer=""></script><script src="/_next/static/1648214313369/_middlewareManifest.js" defer=""></script><style data-href="https://fonts.googleapis.com/css?family=Roboto">@font-face{font-family:'Roboto';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4mxM.woff) format('woff')}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu72xKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0460-052F,U+1C80-1C88,U+20B4,U+2DE0-2DFF,U+A640-A69F,U+FE2E-FE2F}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu5mxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0400-045F,U+0490-0491,U+04B0-04B1,U+2116}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7mxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+1F00-1FFF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4WxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0370-03FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7WxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0102-0103,U+0110-0111,U+0128-0129,U+0168-0169,U+01A0-01A1,U+01AF-01B0,U+1EA0-1EF9,U+20AB}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu7GxKKTU1Kvnz.woff2) format('woff2');unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF}@font-face{font-family:'Roboto';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/roboto/v29/KFOmCnqEu92Fr1Mu4mxKKTU1Kg.woff2) format('woff2');unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD}</style></head><body class="custom_class"><div id="__next" data-reactroot=""><div><div></div><div><nav class="navbar is-boxed is-fixed-top"><div class="navbar-brand"><a class="navbar-item " style="font-family:Roboto;font-weight:bold;font-size:1.5em;color:cadetblue" href="/">GiBoOw</a><div class="navbar-burger burger"><span></span><span></span><span></span></div></div><div class="navbar-start"><a class="navbar-item is-tab is-hidden-mobile" href="/">Accueil</a><a class="navbar-item is-tab is-hidden-mobile" href="/posts">Posts</a><a class="navbar-item is-tab is-hidden-mobile" href="/a-propos">A propos</a></div><div class="navbar-end navbar-menu"><a class="navbar-item is-tab is-hidden-tablet" href="/">Accueil</a><a class="navbar-item is-tab is-hidden-tablet" href="/posts">Posts</a><a class="navbar-item is-tab is-hidden-tablet" href="/a-propos">A propos</a></div></nav></div><div><div class="container main-container mt-1"><nav class="breadcrumb is-hidden-touch" aria-label="breadcrumbs"><ul><li><a href="/">Accueil</a></li><li><a href="/posts">Posts</a></li><li class="is-active"><a href="#">PostgreSQL - Comment booster ses recherches de point géolocalisé</a></li></ul></nav></div><article><header class="article-header mt-1"><section class="hero is-secondary hero-background has-background is-blogpost"><img class="hero-background is-transparent" src="/static/images/post/postgres-geoloc-optim.png"/><div class="hero-body"><div class="container"><div class="title">PostgreSQL - Comment booster ses recherches de point géolocalisé</div><div class="metadata"><div class="image is-24x24 is-pulled-left mr-2"><img src="https://github.com/giboow.png?size=28" class="is-rounded" alt="author"/></div><time class="is-left" dateTime="2022-03-24T00:00:00Z">24 mars 2022</time></div></div></div></section></header><div class="container"><section class="section"><div class="content"><p>Récemment j’ai voulu créer une petite application mobile qui permet de rechercher les boîtes aux lettres qui sont autour de la géolocalisation utilisateur. D’autres apps existent, mais leurs performances n’étaient pas vraiment au rendez-vous, alors j’ai voulu tenter de trouver des solutions!</p>
<p>Pour commencer, j’ai réussi à récupérer un jeu de donnée sur le site <a href="http://data.gouv.fr/">data.gouv.fr</a> : <a href="https://www.data.gouv.fr/fr/datasets/liste-des-boites-aux-lettres-de-rue-france-metropolitaine-et-dom-avec-heure-limite-de-depot-1/">https://www.data.gouv.fr/fr/datasets/liste-des-boites-aux-lettres-de-rue-france-metropolitaine-et-dom-avec-heure-limite-de-depot-1/</a> . Ce jeu de données comporte 140 000 entrées, bien sûr l’utilisateur qui va vouloir afficher les boîtes aux lettres proches de lui, n’aura pas besoin d’afficher toutes les boîtes disponibles dans la base de données, mais seulement celles proches de lui, par exemple 10km.</p>
<p>Pour mon projet j’utilise une API SpringBoot, mais ce n’est pas ce qui va vous intéresser aujourd’hui. Le vrai problème c’est comment récupérer l’ensemble des données, stockées dans une base de données PostgreSQL, qui sont géolocalisées proche d’un point dans un temps convenable!</p>
<h2>L’objectif</h2>
<p>Mon objectif est donc de trouver un ensemble de points qui se trouvent dans un rayon de 10km, en un temps record!</p>
<p><img src="/static/images/post/postgres-geoloc-optim.png" alt="Objectif de la requete"></p>
<h2>PostGIS à la rescousse</h2>
<p>PostGIS est une extension de PostgreSQL, elle permet d’offrir de nouvelle fonction et des types de données qui facilitent les recherches géolocalisées.</p>
<p>Pour installer PostGIS sur son serveur :</p>
<pre><code>~$ sudo apt install postgis
</code></pre>
<p>Il faut ensuite l’activer dans PosgresSQL, en se connectant à la base de données et en ajoutant l’extension <strong>postgis</strong>. Elle sera donc active uniquement dans la base de données sélectionnée.</p>
<pre><code>psql (13.6 (Ubuntu 13.6-0ubuntu0.21.10.1))
Type "help" for help.

postgres=# \c test;
postgres=# CREATE EXTENSION postgis;
</code></pre>
<p>Nous pouvons maintenant créer une table qui contient un id, une latitude, une longitude ainsi qu’un point GPS.  La valeur du SRID <strong>4326</strong>  permet de déclarer un point utilisant le système de référence spatiale géographique.</p>
<pre><code>CREATE TABLE public.test (
    id bigserial NOT NULL,
    lat real NOT NULL,
    long real NOT NULL,
    location geography(Point, 4326) NOT NULL
);
</code></pre>
<p>On peut alors facilement ajouter un point en utilisant la requête suivante :</p>
<pre><code>INSERT INTO test (lat, long, location)
VALUES (49.548462,1.0779799,ST_SetSRID(ST_MakePoint(49.548462,1.0779799), 4326));
</code></pre>
<h2>Optimisation</h2>
<p>Pour valider mon optimisation, j’ai ajouté à ma table 140 000 lignes de données géolocalisées.</p>
<p>Bêtement j’ai voulu rechercher tous les points qui se trouvaient dans un rayon de moins de 10km avec la fonction <strong>st_distancesphere</strong>.</p>
<p>Voici la requête que j’exécute pour récupérer tous les points GPS dans un rayon de 10km :</p>
<pre><code>EXPLAIN(ANALYSE , BUFFERS )
SELECT st_distancesphere(t.location::geometry,ST_SetSRID(ST_MakePoint(49.548462,1.0779799), 4326))
FROM test t
WHERE
st_distancesphere(t.location::geometry,ST_SetSRID(ST_MakePoint(49.548462,1.0779799), 4326)) &#x3C; 10000;
</code></pre>
<p>L’analyser de requête de PostgeSQL montre bien qu’aucun index n’est utilisé et que la requête prend 463ms pour renvoyer 21 points qui correspondes aux conditions.</p>
<pre><code>Gather  (cost=1000.00..2776968.00 rows=47062 width=8) (actual time=160.851..461.391 rows=115 loops=1)
  Workers Planned: 1
  Workers Launched: 1
  Buffers: shared hit=1759
  ->  Parallel Seq Scan on test t  (cost=0.00..2771261.80 rows=27684 width=8) (actual time=218.887..415.046 rows=58 loops=2)
"        Filter: (st_distance(geography((location)::geometry), '0101000020E6100000A48CB80034C64840F5EC03DA673FF13F'::geography, false) &#x3C; '10000'::double precision)"
        Rows Removed by Filter: 70535
        Buffers: shared hit=1759
Planning Time: 0.376 ms
JIT:
  Functions: 8
"  Options: Inlining true, Optimization true, Expressions true, Deforming true"
"  Timing: Generation 2.485 ms, Inlining 178.841 ms, Optimization 117.797 ms, Emission 56.983 ms, Total 356.106 ms"
Execution Time: 463.431 ms
</code></pre>
<p>Nous allons donc créer un index qui va permettre d’accélérer la requête (voir  la doc <a href="http://postgis.net/workshops/postgis-intro/indexing.html">http://postgis.net/workshops/postgis-intro/indexing.html</a>):</p>
<pre><code>CREATE INDEX test_position_geography_index ON test USING GIST(geography(location));
</code></pre>
<p>Mais nous allons avoir une mauvaise surprise, car l’index ne fonctionne toujours pas. Après une recherche rapide, je me suis aperçu qu’il n’y a que certaines fonctions de PostGIS qui peuvent utiliser l’indexation (voir la doc ici : <a href="http://postgis.net/workshops/postgis-intro/indexing.html#spatially-indexed-functions">http://postgis.net/workshops/postgis-intro/indexing.html#spatially-indexed-functions</a>).</p>
<p>Je décide donc d’utiliser la fonction ST_DWithin qui renvoie un vrai si deux points se trouvent bien à la distance passée dans le 3e paramètre.</p>
<p>Voici donc la requête suivie de l’analyse :</p>
<pre><code>EXPLAIN(ANALYSE , BUFFERS )
SELECT st_distancesphere(t.location::geometry,ST_SetSRID(ST_MakePoint(49.548462,1.0779799), 4326))
FROM test t
WHERE
   ST_DWithin(t.location, ST_SetSRID(ST_MakePoint(49.548462,1.0779799), 4326)::geography, 10000);
</code></pre>
<pre><code>Bitmap Heap Scan on test t  (cost=4.95..2390.34 rows=14 width=8) (actual time=1.212..2.205 rows=115 loops=1)
"  Filter: st_dwithin(location, '0101000020E6100000A48CB80034C64840F5EC03DA673FF13F'::geography, '10000'::double precision, true)"
  Rows Removed by Filter: 200
  Heap Blocks: exact=150
  Buffers: shared hit=188
  ->  Bitmap Index Scan on test_position_geography_index  (cost=0.00..4.95 rows=72 width=0) (actual time=0.288..0.288 rows=315 loops=1)
"        Index Cond: (location &#x26;&#x26; _st_expand('0101000020E6100000A48CB80034C64840F5EC03DA673FF13F'::geography, '10000'::double precision))"
        Buffers: shared hit=26
Planning Time: 0.446 ms
Execution Time: 2.288 ms
</code></pre>
<p>On voit bien que l’index <strong>test_position_geography_index</strong> est utilisé et qu’il permet de récupérer les 21 points en <strong>2.288ms</strong> 🤯. ****Le gain est énorme, il permet de réduire considérablement le temps d’exécution et le temps d’utilisation processeur.</p>
<h2>Bilan</h2>
<p>Dans mon API de géolocalisation de boîtes aux lettres, cela m’a permis de diviser par 10 le temps de requête et de soulager le serveur lorsque je simulais une charge serveur avec l’outil de tests de performance d’Apache <strong>ab</strong> (<a href="https://httpd.apache.org/docs/2.4/fr/programs/ab.html">https://httpd.apache.org/docs/2.4/fr/programs/ab.html</a>).</p>
</div></section></div></article></div><footer class="footer"><div class="container"><div class="columns is-vcentered"><div class="column is-offset-1-desktop is-4 is-6-mobile"><div class="content is-large"><div class="columns is-mobile"><div class="column"><a title="Twitter" class="icon" href="https://twitter.com/giboow"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="twitter" class="svg-inline--fa fa-twitter fa-w-16 " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></a></div><div class="column"><a title="LinkedIn" class="icon" href="https://www.linkedin.com/in/pgibert/"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="linkedin" class="svg-inline--fa fa-linkedin fa-w-14 " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg></a></div><div class="column"><a title="Github" class="icon" target="_blank" href="https://github.com/giboow/"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16 " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a></div><div class="column"><a title="Contactez moi" class="icon" href="/contact"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="weixin" class="svg-inline--fa fa-weixin fa-w-18 " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><path fill="currentColor" d="M385.2 167.6c6.4 0 12.6.3 18.8 1.1C387.4 90.3 303.3 32 207.7 32 100.5 32 13 104.8 13 197.4c0 53.4 29.3 97.5 77.9 131.6l-19.3 58.6 68-34.1c24.4 4.8 43.8 9.7 68.2 9.7 6.2 0 12.1-.3 18.3-.8-4-12.9-6.2-26.6-6.2-40.8-.1-84.9 72.9-154 165.3-154zm-104.5-52.9c14.5 0 24.2 9.7 24.2 24.4 0 14.5-9.7 24.2-24.2 24.2-14.8 0-29.3-9.7-29.3-24.2.1-14.7 14.6-24.4 29.3-24.4zm-136.4 48.6c-14.5 0-29.3-9.7-29.3-24.2 0-14.8 14.8-24.4 29.3-24.4 14.8 0 24.4 9.7 24.4 24.4 0 14.6-9.6 24.2-24.4 24.2zM563 319.4c0-77.9-77.9-141.3-165.4-141.3-92.7 0-165.4 63.4-165.4 141.3S305 460.7 397.6 460.7c19.3 0 38.9-5.1 58.6-9.9l53.4 29.3-14.8-48.6C534 402.1 563 363.2 563 319.4zm-219.1-24.5c-9.7 0-19.3-9.7-19.3-19.6 0-9.7 9.7-19.3 19.3-19.3 14.8 0 24.4 9.7 24.4 19.3 0 10-9.7 19.6-24.4 19.6zm107.1 0c-9.7 0-19.3-9.7-19.3-19.6 0-9.7 9.7-19.3 19.3-19.3 14.5 0 24.4 9.7 24.4 19.3.1 10-9.9 19.6-24.4 19.6z"></path></svg></a></div></div></div></div><div class="column is-offset-4-desktop is-4-desktop"><div class="content is-small">© <!-- -->2022<!-- --> - Made with ♥ By <a href="https://twitter.com/giboow">Giboow</a></div></div></div></div></footer></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"postgresql-optim-requete-geoloc","contentHtml":"\u003cp\u003eRécemment j’ai voulu créer une petite application mobile qui permet de rechercher les boîtes aux lettres qui sont autour de la géolocalisation utilisateur. D’autres apps existent, mais leurs performances n’étaient pas vraiment au rendez-vous, alors j’ai voulu tenter de trouver des solutions!\u003c/p\u003e\n\u003cp\u003ePour commencer, j’ai réussi à récupérer un jeu de donnée sur le site \u003ca href=\"http://data.gouv.fr/\"\u003edata.gouv.fr\u003c/a\u003e : \u003ca href=\"https://www.data.gouv.fr/fr/datasets/liste-des-boites-aux-lettres-de-rue-france-metropolitaine-et-dom-avec-heure-limite-de-depot-1/\"\u003ehttps://www.data.gouv.fr/fr/datasets/liste-des-boites-aux-lettres-de-rue-france-metropolitaine-et-dom-avec-heure-limite-de-depot-1/\u003c/a\u003e . Ce jeu de données comporte 140 000 entrées, bien sûr l’utilisateur qui va vouloir afficher les boîtes aux lettres proches de lui, n’aura pas besoin d’afficher toutes les boîtes disponibles dans la base de données, mais seulement celles proches de lui, par exemple 10km.\u003c/p\u003e\n\u003cp\u003ePour mon projet j’utilise une API SpringBoot, mais ce n’est pas ce qui va vous intéresser aujourd’hui. Le vrai problème c’est comment récupérer l’ensemble des données, stockées dans une base de données PostgreSQL, qui sont géolocalisées proche d’un point dans un temps convenable!\u003c/p\u003e\n\u003ch2\u003eL’objectif\u003c/h2\u003e\n\u003cp\u003eMon objectif est donc de trouver un ensemble de points qui se trouvent dans un rayon de 10km, en un temps record!\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/static/images/post/postgres-geoloc-optim.png\" alt=\"Objectif de la requete\"\u003e\u003c/p\u003e\n\u003ch2\u003ePostGIS à la rescousse\u003c/h2\u003e\n\u003cp\u003ePostGIS est une extension de PostgreSQL, elle permet d’offrir de nouvelle fonction et des types de données qui facilitent les recherches géolocalisées.\u003c/p\u003e\n\u003cp\u003ePour installer PostGIS sur son serveur :\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e~$ sudo apt install postgis\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIl faut ensuite l’activer dans PosgresSQL, en se connectant à la base de données et en ajoutant l’extension \u003cstrong\u003epostgis\u003c/strong\u003e. Elle sera donc active uniquement dans la base de données sélectionnée.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003epsql (13.6 (Ubuntu 13.6-0ubuntu0.21.10.1))\nType \"help\" for help.\n\npostgres=# \\c test;\npostgres=# CREATE EXTENSION postgis;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNous pouvons maintenant créer une table qui contient un id, une latitude, une longitude ainsi qu’un point GPS.  La valeur du SRID \u003cstrong\u003e4326\u003c/strong\u003e  permet de déclarer un point utilisant le système de référence spatiale géographique.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCREATE TABLE public.test (\n    id bigserial NOT NULL,\n    lat real NOT NULL,\n    long real NOT NULL,\n    location geography(Point, 4326) NOT NULL\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOn peut alors facilement ajouter un point en utilisant la requête suivante :\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eINSERT INTO test (lat, long, location)\nVALUES (49.548462,1.0779799,ST_SetSRID(ST_MakePoint(49.548462,1.0779799), 4326));\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eOptimisation\u003c/h2\u003e\n\u003cp\u003ePour valider mon optimisation, j’ai ajouté à ma table 140 000 lignes de données géolocalisées.\u003c/p\u003e\n\u003cp\u003eBêtement j’ai voulu rechercher tous les points qui se trouvaient dans un rayon de moins de 10km avec la fonction \u003cstrong\u003est_distancesphere\u003c/strong\u003e.\u003c/p\u003e\n\u003cp\u003eVoici la requête que j’exécute pour récupérer tous les points GPS dans un rayon de 10km :\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eEXPLAIN(ANALYSE , BUFFERS )\nSELECT st_distancesphere(t.location::geometry,ST_SetSRID(ST_MakePoint(49.548462,1.0779799), 4326))\nFROM test t\nWHERE\nst_distancesphere(t.location::geometry,ST_SetSRID(ST_MakePoint(49.548462,1.0779799), 4326)) \u0026#x3C; 10000;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eL’analyser de requête de PostgeSQL montre bien qu’aucun index n’est utilisé et que la requête prend 463ms pour renvoyer 21 points qui correspondes aux conditions.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eGather  (cost=1000.00..2776968.00 rows=47062 width=8) (actual time=160.851..461.391 rows=115 loops=1)\n  Workers Planned: 1\n  Workers Launched: 1\n  Buffers: shared hit=1759\n  -\u003e  Parallel Seq Scan on test t  (cost=0.00..2771261.80 rows=27684 width=8) (actual time=218.887..415.046 rows=58 loops=2)\n\"        Filter: (st_distance(geography((location)::geometry), '0101000020E6100000A48CB80034C64840F5EC03DA673FF13F'::geography, false) \u0026#x3C; '10000'::double precision)\"\n        Rows Removed by Filter: 70535\n        Buffers: shared hit=1759\nPlanning Time: 0.376 ms\nJIT:\n  Functions: 8\n\"  Options: Inlining true, Optimization true, Expressions true, Deforming true\"\n\"  Timing: Generation 2.485 ms, Inlining 178.841 ms, Optimization 117.797 ms, Emission 56.983 ms, Total 356.106 ms\"\nExecution Time: 463.431 ms\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNous allons donc créer un index qui va permettre d’accélérer la requête (voir  la doc \u003ca href=\"http://postgis.net/workshops/postgis-intro/indexing.html\"\u003ehttp://postgis.net/workshops/postgis-intro/indexing.html\u003c/a\u003e):\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eCREATE INDEX test_position_geography_index ON test USING GIST(geography(location));\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eMais nous allons avoir une mauvaise surprise, car l’index ne fonctionne toujours pas. Après une recherche rapide, je me suis aperçu qu’il n’y a que certaines fonctions de PostGIS qui peuvent utiliser l’indexation (voir la doc ici : \u003ca href=\"http://postgis.net/workshops/postgis-intro/indexing.html#spatially-indexed-functions\"\u003ehttp://postgis.net/workshops/postgis-intro/indexing.html#spatially-indexed-functions\u003c/a\u003e).\u003c/p\u003e\n\u003cp\u003eJe décide donc d’utiliser la fonction ST_DWithin qui renvoie un vrai si deux points se trouvent bien à la distance passée dans le 3e paramètre.\u003c/p\u003e\n\u003cp\u003eVoici donc la requête suivie de l’analyse :\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eEXPLAIN(ANALYSE , BUFFERS )\nSELECT st_distancesphere(t.location::geometry,ST_SetSRID(ST_MakePoint(49.548462,1.0779799), 4326))\nFROM test t\nWHERE\n   ST_DWithin(t.location, ST_SetSRID(ST_MakePoint(49.548462,1.0779799), 4326)::geography, 10000);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eBitmap Heap Scan on test t  (cost=4.95..2390.34 rows=14 width=8) (actual time=1.212..2.205 rows=115 loops=1)\n\"  Filter: st_dwithin(location, '0101000020E6100000A48CB80034C64840F5EC03DA673FF13F'::geography, '10000'::double precision, true)\"\n  Rows Removed by Filter: 200\n  Heap Blocks: exact=150\n  Buffers: shared hit=188\n  -\u003e  Bitmap Index Scan on test_position_geography_index  (cost=0.00..4.95 rows=72 width=0) (actual time=0.288..0.288 rows=315 loops=1)\n\"        Index Cond: (location \u0026#x26;\u0026#x26; _st_expand('0101000020E6100000A48CB80034C64840F5EC03DA673FF13F'::geography, '10000'::double precision))\"\n        Buffers: shared hit=26\nPlanning Time: 0.446 ms\nExecution Time: 2.288 ms\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOn voit bien que l’index \u003cstrong\u003etest_position_geography_index\u003c/strong\u003e est utilisé et qu’il permet de récupérer les 21 points en \u003cstrong\u003e2.288ms\u003c/strong\u003e 🤯. ****Le gain est énorme, il permet de réduire considérablement le temps d’exécution et le temps d’utilisation processeur.\u003c/p\u003e\n\u003ch2\u003eBilan\u003c/h2\u003e\n\u003cp\u003eDans mon API de géolocalisation de boîtes aux lettres, cela m’a permis de diviser par 10 le temps de requête et de soulager le serveur lorsque je simulais une charge serveur avec l’outil de tests de performance d’Apache \u003cstrong\u003eab\u003c/strong\u003e (\u003ca href=\"https://httpd.apache.org/docs/2.4/fr/programs/ab.html\"\u003ehttps://httpd.apache.org/docs/2.4/fr/programs/ab.html\u003c/a\u003e).\u003c/p\u003e\n","author":"giboow","title":"PostgreSQL - Comment booster ses recherches de point géolocalisé","date":"2022-03-24","keywords":["PostgreSQL","PostGIS","Latitude","Longitude","Optimisation","SQL"],"image":"/static/images/post/postgres-geoloc-optim.png"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"postgresql-optim-requete-geoloc"},"buildId":"1648214313369","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>